== Syntax ==

The program's source code must be encoded in UTF-8.

=== Comments ===

Comments start with the sharp (`'#'`) character.
Only one-line comments are supported for now.

[source,ruby]
-------------
# This is a comment
-------------

=== Local Variables ===

Local variables start with lowercase letters or underscore.
They are declared when you first assign them a value.

[source,ruby]
-------------
name = "Crystal"
age = 1
-------------

Their type is inferred from their usage, not only from their initializer.
In general, they are just value holders associated with the type that
the programmer expects them to have according to their location and usage
on the program.

For example, reassinging a variable with a different expression makes it have
that expression's type:

[source,ruby]
-------------
var = "Hello"
# At this point 'var' is a String

var = 1
# At this point 'var' is an Int32
-------------

=== Global Variables ===

Global variables start with a dollar sign (`'$'`).
They are declared when you first assign them a value.

[source,ruby]
-------------
$year = 2014
-------------

Their type is the combined type of all expressions that were assigned to them.
Additionally, if you program reads a global variable before it was ever assigned
a value it will also have the `Nil` type.

==== Thread-local global variables ====

You can mark a global variable as thread-local with the `@:ThreadLocal` attribute:

[source,ruby]
-------------
@:ThreadLocal
$year = 2014
-------------

=== Assignment ===

Assignment is done with the equal (`'='`) character.

[source,ruby]
-------------
local = 1
@instance = 2
@@class = 3
$global = 4
-------------

Some syntax sugar that contains the `'='` character is available:

[source,ruby]
-------------
local += 1  # same as: local = local + 1

# The above is valid with these operators:
# +, -, *, /, %, |, &, ^, **, <<, >>

local ||= 1 # same as: local || (local = 1)
local &&= 1 # same as: local && (local = 1)
-------------

A method invocation that ends with `'='` has syntax sugar:

[source,ruby]
-------------
# A setter
person.name=("John")

# The above can be written as:
person.name = "John"

# An indexed assignment
objects.[]=(2, 3)

# The above can be written as:
objects[2] = 3
-------------

The `=` operator syntax sugar is also available to setters and
indexers. Note that `||` and `&&` use the `[]?` method to check
for key prescence.

[source,ruby]
-------------
person.age += 1        # same as: person.name = person.name + 1

person.name ||= "John" # same as: person.name || (person.name = "John")
person.name &&= "John" # same as: person.name && (person.name = "John")

objects[1] += 2        # same as: objects[1] = objects[1] + 2

objects[1] ||= 2       # same as: objects[1]? || (objects[1] = 2)
objects[1] &&= 2       # same as: objects[1]? && (objects[1] = 2)
-------------

=== Multiple assignment ===

You can declare/assign multiple variables at the same time by separating
expressions with a comma (`','`):

[source,ruby]
-------------
name, age = "Crystal", 1

# The above is the same as this:
temp1 = "Crystal"
temp2 = 1
name = temp1
aeg = temp2
-------------

Note that because expressions are assigned to temporary variables it is
possible to exchange variables's contents in a single line:

[source,ruby]
-------------
a, b = 1, 2
a, b = b, a
# Now a is 2 and b is 1
-------------

If the right-hand side contains just one expression, it is considered
an indexed type and the following syntax sugar applies:

[source,ruby]
-------------
name, age, source = "Crystal,1,github".split(",")

# The above is the same as this:
temp = "Crystal,1".split(",")
name   = temp[0]
age    = temp[1]
source = temp[2]
-------------

If the left-hand side contains just one variable, the right-hand side
is considered an array:

[source,ruby]
-------------
names = "John", "Peter", "Jack"

# The above is the same as:
names = ["John", "Peter", "Jack"]
-------------

Multiple assignment is also available to methods that end with `=`:

[source,ruby]
-------------
person.name, person.age = "John", 32

# Same as:
temp1 = "John"
temp2 = 32
person.name = temp1
person.age = temp2
-------------

And it is also available to indexers (`[]=`):

[source,ruby]
-------------
objects[1], objects[2] = 3, 4

# Same as:
temp1 = 3
temp2 = 4
objects[1] = 3
objects[2] = 4
-------------


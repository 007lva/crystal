==== if

An `if` evaluates the `then` branch if its condition is truthy, and evaluates
the `else` branch, if there's any, otherwise.

[source,ruby]
-------------
a = 1
if a > 0
  a = 10
end
# Here a will be 10

b = 1
if b > 2
  b = 10
else
  b = 20
end
# Here b will be 20
-------------

After an `if`, a variable's type depends on the type of the expressions used in both
branches.

[source,ruby]
-------------
a = 1
if some_condition
  a = "hello"
else
  a = true
end
# Here a is String or Bool

b = 1
if some_condition
  b = "hello"
end
# Here b is Int32 or String

if some_condition
  c = 1
else
  c = "hello"
end
# Here c is Int32 or String

if some_condition
  d = 1
end
# Here d is Int32 or Nil
-------------

Note that if a variable is declared inside one of the branches but not in the other one,
at the end of the `if` it will also contain the `Nil` type.

Inside an `if`'s branch the type of a variable is the one it got assigned in that
branch, or the one that it had before the branch if it was not reassigned:

[source,ruby]
-------------
a = 1
if some_condition
  a = "hello"
  # here a is String, so the following call is valid
  a.length
end
# here a is String or Int32
-------------

That is, a variable's type is the type of the last expression(s) assigned to it.

If one of the branches never reaches past the end of an if, like in the case
of a `return`, `next`, `break` or `raise`, that type is not considered at the end of
the `if`:


[source,ruby]
-------------
if some_condition
  e = 1
else
  e = "hello"
  # here e is String
  return
end
# here e is Int32
-------------

===== As a suffix

An `if` can be written as an expression's suffix:

[source,ruby]
-------------
a = 2 if some_condition

# The above is the same as:
if some_condition
  a = 2
end
-------------

This sometimes leads to code that is more natural to read.

===== As an expression

The value of an `if` is the value of the last expression found in
each of its branches:

[source,ruby]
-------------
a = if 2 > 1
      3
    else
      4
    end
# Here a will be 3
-------------

If an `if` branch is empty, or it's missing, it's considered as if
it had `nil` in it:

[source,ruby]
-------------
if 1 > 2
  3
end

# The above is the same as:
if 1 > 2
  3
else
  nil
end

# Another example:
if 1 > 2
else
  3
end

# The above is the same as:
if 1 > 2
  nil
else
  3
end
-------------

===== Ternary if

The ternary `if` allows writing an `if` in a shorter way:

[source,ruby]
-------------
a = 1 > 2 ? 3 : 4

# The above is the same as:
a = if 1 > 2
      3
    else
      4
    end
-------------

===== if var

If a variable is the condition of an `if`, inside the `then` branch the
variable will be considered as not having the `Nil` type:

[source,ruby]
-------------
a = 1 > 2 ? nil : 3
# a is Int32 or Nil

if a
  # Since the only way to get here is if a is truthy,
  # a can't be nil. So here a is Int32.
  a.abs
end
-------------

This also applies when a variable is assigned in an `if`'s condition:

[source,ruby]
-------------
if a = some_expression
  # here a is not nil
end
-------------

This logic also applies if there are ands (`&&`) in the condition:

[source,ruby]
-------------
if a && b
  # here both a and b are guaranteed not to be Nil
end
-------------

Here, the right-hand side of the `&&` expression is also guaranteed
to have `a` as not `Nil`.

Of course, reassigning a variable inside the `then` branch makes
that variable have a new type based on the expression assigned.

The above logic doesn't work with instance variables, class variables
or global variables:

[source,ruby]
-------------
if @a
  # here @a can be nil
end
-------------

This is because any method call could potentially affect that
instance variable, rendering it `nil`. Another reason is that another
thread could change that instance variable after checking the condition.

To do something with `@a` only when it is not nil you have two options:

[source,ruby]
-------------
# First option: assign it to a variable
if a = @a
  # here a can't be nil
end

# Second option: use `Object#try` found in the standard library
@a.try do |a|
  # here a can't be nil
end
-------------

===== if var.is_a?

If an `if`'s condition is an `is_a?` test, the type of a variable is
guaranteed to be restricted by that type:

[source,ruby]
-------------
if a.is_a?(String)
  # here a is a String
end

if b.is_a?(Number)
  # here b is a Number
end
-------------

Note that you can use any type as an `is_a?` test, like abstract classes
and modules.

The above also works if there are ands (`&&`) in the condition:

[source,ruby]
-------------
if a.is_a?(String) && b.is_a?(Number)
  # here a is a String and b is a Number
end
-------------

This doesn't work with instance variables, class variables or global variables.
To work with these, first assign them to a variable:

[source,ruby]
-------------
if @a.is_a?(String)
  # here @a is not guaranteed to be a String
end

a = @a
if a.is_a?(String)
  # here a is guaranteed to be a String
end
-------------

===== if var.responds_to?

If an `if`'s condition is a `responds_to?` test, the type of a variable is
guaranteed to be restricted by that types that respond to that method:

[source,ruby]
-------------
if a.responds_to?(:abs)
  # here a's type will be reduced to those responding to the 'abs' method
end
-------------

